<?php
    //This class catches and manages errors and exceptions 
    class Debugger
    {
        private $data = array();
        private $handlers = array();

        public function __construct()
        {
            //turn on all error reporting
            error_reporting(E_ALL);
            ini_set('display_errors', 1);
            ini_set('display_startup_errors', 1);

            // error_reporting(0);
            // ini_set('display_errors', 0);
            // ini_set('display_startup_errors', 0);
            
            //begin output capture
            ob_start();
        }

        //Adds a new callback function to handle error data
        public function addHandler($handlerFunc)
        {
            array_push($this->handlers, $handlerFunc);
        }

        //Unified method to accept notices, warnings, errors, and exceptions
        private function newEvent($type, $file, $line, $msg)
        {
            $this->data['time'] = microtime(true);
            $this->data['type'] = $type;
            $this->data['file'] = $file;
            $this->data['line'] = $line;
            $this->data['msg'] = $msg;
            $this->data['backtrace'] = debug_backtrace();

            //log to php console
            if($this->data['type'] == 'exception')
            {
                http_response_code(500);
                error_log(' Exception: '.$this->data['msg'].' -> '.$this->data['file'].'@line:'.$this->data['line']);
            }
            else
            {
                if($this->data['type']==E_USER_ERROR || $this->data['type']==E_ERROR)
                    http_response_code(500);

                error_log(' Code:'.$this->data['type'].' '.$this->data['msg'].' -> '.$this->data['file'].'@line:'.$this->data['line']);
            }
        }

        //Call all user functions and pass error data to them
        private function runHandlers()
        {
            set_error_handler(function()
            {
                echo "well, this is awkward...<br>";
                error_log('handler bug');
            }, E_ALL);

            //set_exception_handler(array($this, 'exception_handler'));
            foreach($this->handlers as $key)
            {
                //make sure a bad handler doesn't kill the program
                try
                {
                    call_user_func($key, $this->data);
                } 
                catch(Exception $e)
                {
                    $this->newEvent('exception', $e->getFile(), $e->getLine(), $e->getMessage());
                }
            }
        }

        //Capture unhandled errors, warnings, notices
        public function error_handler($errorNo, $message, $file, $line)
        {
            //If E_ERROR/E_USER_ERROR, erase all previous output
            if($errorNo == 256 || $errorNo == 1) 
                ob_end_clean();

            $this->newEvent($errorNo, $file, $line, $message);
            $this->runHandlers();

            //If error = E_USER_ERROR/E_ERROR, kill code
            if($errorNo == 256 || $errorNo == 1) 
                exit();
        }

        //Capture unhandled exceptions
        public function exception_handler($exception)
        {
            ob_end_clean();
            
            $this->newEvent('exception', $exception->getFile(), $exception->getLine(), $exception->getMessage());
            $this->runHandlers();

            exit();
        }

        //Enable or disable error/exception handlers
        public function enable($state)
        {
            if($state===true)
            {
                set_error_handler(array($this, 'error_handler'), E_ALL); 
                set_exception_handler(array($this, 'exception_handler')); 
            }
            else
            {
                if($state===false)
                {
                    restore_error_handler();
                    restore_exception_handler();
                }
            }
        }
    }
?>
